---
layout: post
title: Creating R package with modern tools
comments: True
---

Recently, I have finished and succesfully released my first R package - yummlyr, and decided a short article on creating R packages. There are different manuals that can be found over the internet, but I wanted something modern, or in short a simplified version of Hadley's R packages book. 

### What is an R package?

For me, R packages was one of the most fundumental things of the language. Essentially, it's a well defined format for distributing R code through CRAN. It took it's idea from CPAN, but outgrew the competition greately and now holds over 7000 packages. 

### Why bother creating an R package?

### How to create a packages

* Through new RStudio project
* Using `package.skeleton`
* Using `devtools::create`

### Structure of a package

After creating a package with RStudio or devtools, you are most likely to see the following structure. 

**Insert a picture here***

It countains the following files/directories:

* DESCRIPTION - description of the package with different characteristics
* NAMESPACE - file that specifies functions that are exported by your package 
* R - a directory that holds R code
* man - directory with function documentation
* .RBuildIgnore - file that specified files excluded from the package building

Files/directories that are not created by default, but are also important:

* src - directory with source code for compiled files, typically Rcpp, sometimes C/C++ or Fortran.
* vignette - directory with long documentation in form of vignettes. This is different from man in a way that it usually describes user scenarios or implementation details, while `man` typically documents single functions.
* tests - directory that contains test files
* inst - header/things specific for installation

#### Package description

DESCRIPTION file stores the important information about your package. The file is in so called Debian-control-file format, which was invented by the Debian Linux distribution (http://www.debian.org) to describe their package. Entries are of form

`Keyword`: `Value`

The fields of DESCRIPTION file are self explanatory and [The DESCRIPTION file](https://cran.r-project.org/doc/manuals/r-release/R-exts.html#The-DESCRIPTION-file) section of the official guide covers them in much detail, which I wouldn't want to duplicate here. For package developer point of view, I feel that most important fields are `Depends` (packages needed to load your package), `Imports` (field lists packages whose namespaces are absolutely essential to package functionality), `Suggests` (packages that are useful, but not essential, for example additional data). The different between `Depends` and `Imports`. The distinction between `Depends` and `Imports` is somewhat unclear, and is explained well in this [SO question](http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends).

#### Package exports

Package namespaces (and NAMESPACE file which essentially records the information about the namespace) are often confusing to people coming from other languages. It is consider an advanced topic and sometimes is pretty complicated, and if you are interested, good references would be [Environments](http://adv-r.had.co.nz/Environments.html) chapter from Hadley's [Advanced R](http://adv-r.had.co.nz/) book. 

As for `NAMESPACE` file, from personal experience, using `roxygen` and correction notation, usually suffices not to touch the file at all. However, knowing what the file actually means is beneficial for more complex projects, so I will attempt to give a short summary here. NAMESPACE file has 8 types of extries:

* `export`: export functions (including S3 and S4 generics).
* `exportPattern`: export all functions that match a pattern.
* `exportClasses`, `exportMethods`: export S4 classes and methods.
* `S3method`: export S3 methods.
* `import`: import all functions from a package.
* `importFrom`: import selected functions (including S4 generics).
* `importClassesFrom`, `importMethodsFrom`: import S4 classes and methods.
* `useDynLib`: import a function from C. This is described in more detail in compiled code.

Again, not that roxygen2 does pretty good job in abstracting the need to change NAMESPACE file directly. Also look at [maxygen](https://github.com/gaborcsardi/maxygen).

#### R source code and data

The "heart" of the package, ie the code lives in `R/` directory. Also note that typically data (in `.Rda` format) typically leaves in this directory too.

#### Compiled code

One of the things that distingishes R from other languages is it's interfances. It's deeply imbedded into how language was designed thus providing great methods for interacting with other systems. Particually R is great in executing compiled code C/C++ code, especially with Rcpp. Unless you have some code that is already written and you just want to hook it up to R, I would recommend using `Rcpp` for writing optimized code that is used in R. The simplies way to start using `Rcpp` in your package is through `devtools` : 

```
devtools::use_rcpp()
```

Which will set up all the needed bits and pieces. 

#### Tests and continious integration

There are two main packages used for testing throughout R community - [testthat](https://github.com/hadley/testthat) and [runit](https://cran.fhcrc.org/web/packages/RUnit/index.html). `testthat` draws inspiration from the xUnit family of testing packages, as well from many of the innovative ruby testing libraries, while `runit` aims to provide similar testing experience to [junit](http://junit.org/). Also `runit` seems to be one of the first testing frameworks for R, but recently `testhat` have been more popular and I rarely see new packages using runit. With testthat being a tool from HadleyVerse, it is also very easy to set it up with `devtools`

```
devtools::use_testthat()
```

During last year, I have seen a significant improvement of CI systems supporting R. Even though most of the tools are written by community, they are robust and make it relatively easy to setup. There are 3 systems, which I have seen primarily used in many packages (which are free for open source projects):

* [Travis](https://travis-ci.org) - arguably most popular CI system. Supports R almost as first class citizen, configuration as simple as adding 
```
language: r
sudo: required
```
to `travis.yml`. As with many tools here, can be setup with `devtools::use_travis`.

* [Wercker](https://wercker.com) - CI systems that is based on docker, which allows it to perform quicker builds than travis (however, travis should have container support soon too). Example for working configuration can be found [here](https://github.com/jimhester/lintr/blob/master/wercker.yml).
* [AppVeyor](http://www.appveyor.com/) - CI systems for Windows and a must to have if you are using compiled code, otherwise there not that many crossplatfom issues with R. Can be setup with `devtools::use_appveyov`.

Last year, Jim Hester created [covr](https://github.com/jimhester/covr/) package for measuring test coverage. Around the same time I was also inverstigating possibilities to measure R code coverage as part of my [research](https://github.com/allr/rcov), so I was searching for work done and covr presented a robust and general solution for the problem. Since it was quickly picked up by [coveralls.io](https://coveralls.io) and [codecov.io](https://codecov.io). In essense, to measure coverage with CI, you will only need to add `covr::coveralls` as part of your build. Also you can use `devtools::use_coveralls`.

#### Function documentation

#### Vignettes

#### CRAN submission and revdep