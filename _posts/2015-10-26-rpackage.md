---
layout: post
title: Creating R package with modern tools
comments: True
---

Recently, I have finished and succesfully released my first R package - yummlyr, and decided a short article on best practices that I have seen for creating R packages. There are many different manuals that can be found over the internet, with great [R packages](http://r-pkgs.had.co.nz/) book by Hadley Wickham for in depth study of the topic, while this article aims to give a short overview of best practices and tools for creating packages. 

### What is an R package?

For me, R packages was one of the most fundumental things of the language. Essentially, it's a well defined format for distributing R code through CRAN. It took it's idea from CPAN, but outgrew the competition greately and now holds over 7000 packages. 

### How to create a packages

* Through new RStudio project
* Using `package.skeleton`
* Using `devtools::create`

#### Package description

DESCRIPTION file stores the important information about your package. The file is in so called Debian-control-file format, which was invented by the Debian Linux distribution (http://www.debian.org) to describe their package. Entries are of form

`Keyword`: `Value`

The fields of DESCRIPTION file are self explanatory and [The DESCRIPTION file](https://cran.r-project.org/doc/manuals/r-release/R-exts.html#The-DESCRIPTION-file) section of the official guide covers them in much detail, which I wouldn't want to duplicate here. For package developer point of view, I feel that most important fields are `Depends` (packages needed to load your package), `Imports` (field lists packages whose namespaces are absolutely essential to package functionality), `Suggests` (packages that are useful, but not essential, for example additional data). The different between `Depends` and `Imports`. The distinction between `Depends` and `Imports` is somewhat unclear, and is explained well in this [SO question](http://stackoverflow.com/questions/8637993/better-explanation-of-when-to-use-imports-depends).

#### Use Rcpp for compiled code

One of the things that distingishes R from other languages is it's interfances. It's deeply imbedded into how language was designed thus providing great methods for interacting with other systems. Particually R is great in executing compiled code C/C++ code, especially with Rcpp. Unless you have some code that is already written and you just want to hook it up to R, I would recommend using `Rcpp` for writing optimized code that is used in R. The simplies way to start using `Rcpp` in your package is through `devtools` : 

```
devtools::use_rcpp()
```

Which will set up all the needed bits and pieces. 

#### Enforce coding style with lintr or formatR

The [formatR](http://yihui.name/formatR/) is a package created by [Yihui Xie](http://yihui.name/) which aims at reformating R code to improve readability; if you are familiar with [gofmt](https://golang.org/cmd/gofmt/) or [rustfmt](https://github.com/nrc/rustfmt), you will easily understand the appeal of the package.

Most obvious usage is 

```
formatR::tidy_dir()
```

which, will format all the files in the package. 

The [lintr](https://github.com/jimhester/lintr) package by [Jim Haster](http://www.jimhester.com/) takes a bit different approach. Rather than trying to fix the error by itself it simply reports them to the user. It is easy to use inside major IDEs. I prefer lintr since it allows to write custom lints and is a bit more configurable in my opinion.

Using `lintr` is also very simple, just call

```
lintr::lint_package()
```

#### Use testthat/runit for writing tests

There are two main packages used for testing throughout R community - [testthat](https://github.com/hadley/testthat) and [runit](https://cran.fhcrc.org/web/packages/RUnit/index.html). `testthat` draws inspiration from the xUnit family of testing packages, as well from many of the innovative ruby testing libraries, while `runit` aims to provide similar testing experience to [junit](http://junit.org/). Also `runit` seems to be one of the first testing frameworks for R, but recently `testhat` have been more popular and I rarely see new packages using runit. So in this short intro I will focus on `testthat`. 

With testthat being a tool from HadleyVerse, it is also very easy to set it up with `devtools`

```
devtools::use_testthat()
```

A test file lives in tests/testthat/. Its name must start with test. Hereâ€™s an example of a test file from the stringr package:
More detailed information can be found on `testthat` [here](http://r-pkgs.had.co.nz/tests.html).

#### Use Travis/Wercker and AppVeyor for Continious Integration

During last year, I have seen a significant improvement of CI systems supporting R. Even though most of the tools are written by community, they are robust and make it relatively easy to setup. There are 3 systems, which I have seen primarily used in many packages (which are free for open source projects):

* [Travis](https://travis-ci.org) - arguably most popular CI system. Supports R almost as first class citizen, configuration as simple as adding 
```
language: r
sudo: required
```
to `travis.yml`. As with many tools here, can be setup with `devtools::use_travis`.

* [Wercker](https://wercker.com) - CI systems that is based on docker, which allows it to perform quicker builds than travis (however, travis should have container support soon too). Example for working configuration can be found [here](https://github.com/jimhester/lintr/blob/master/wercker.yml).
* [AppVeyor](http://www.appveyor.com/) - CI systems for Windows and a must to have if you are using compiled code, otherwise there not that many crossplatfom issues with R. Can be setup with `devtools::use_appveyov`.


#### Use covr to measure code coverage

Last year, Jim Hester created [covr](https://github.com/jimhester/covr/) package for measuring test coverage. Use

```
covr::package_coverage()
```

to get quick statistics for code coverage of your package and 

```
covr::shine(covr::package_coverage())
```

to inspect line by line code coverage inside shiny app.

Also `covr` is supported by [coveralls.io](https://coveralls.io) and [codecov.io](https://codecov.io) with allows to nice integration of code coverage into CI pipeline. In essense, to measure coverage with CI, you will only need to add `covr::coveralls` as part of your CI build. Just call,

```
devtools::use_coveralls()
```

For detailed instrunctions. Replace `coveralls` with `codecov` if you want to use it instead.

#### Use roxygen2 for function documentation

#### Use knitr for Vignettes

#### CRAN submission and revdep